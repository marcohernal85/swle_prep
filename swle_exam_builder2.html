<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PRC-Aligned SWLE Exam Builder (All Subjects)</title>
  <style>
    :root{
      --bg:#0f172a;--card:#111827;--muted:#1f2937;--text:#e5e7eb;--accent:#22d3ee;--good:#22c55e;--bad:#ef4444;--warn:#f59e0b;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;background:var(--bg);color:var(--text)}
    .wrap{max-width:1100px;margin:40px auto;padding:0 16px}
    .row{display:flex;gap:16px;flex-wrap:wrap}
    .card{background:linear-gradient(180deg,#111827, #0b1220);border:1px solid #1f2937;border-radius:18px;padding:16px;box-shadow:0 10px 25px rgba(0,0,0,.25)}
    .card h2,.card h3{margin:0 0 16px;font-size:1.5rem}
    .card p{margin:0 0 16px;line-height:1.5}
    .col{flex:1;min-width:300px}
    select,button,input[type=number]{width:100%;padding:10px 12px;border-radius:8px;border:1px solid var(--muted);background:var(--muted);color:var(--text);font-size:1rem;margin-bottom:12px;cursor:pointer}
    button.alt-btn{background:transparent;border:1px solid var(--accent);color:var(--accent);font-size:0.9rem}
    button.alt-btn:hover{background:var(--accent);color:var(--bg)}
    .progress-wrap{width:100%;background:var(--muted);height:8px;border-radius:4px;margin-bottom:12px;overflow:hidden}
    #bar{height:100%;width:0%;background:var(--accent);transition:width .3s ease-in-out}
    .q{background:var(--card);padding:16px;border-radius:12px;border:1px solid var(--muted);margin-bottom:16px}
    .choices{display:flex;flex-direction:column;gap:8px;margin-top:12px}
    .choice{padding:10px 12px;border:1px solid var(--muted);border-radius:8px;cursor:pointer;transition:background-color .2s}
    .choice:hover{background:var(--muted)}
    .choice.selected{border-color:var(--accent);background:var(--muted)}
    .choice.correct{background:var(--good);color:#fff;border-color:var(--good)}
    .choice.wrong{background:var(--bad);color:#fff;border-color:var(--bad)}
    .hide{display:none}
    .metrics{font-size:.9rem;text-align:right}
    #metaScore{font-size:1.5rem;font-weight:700}
    .rationale{margin-top:16px;padding:12px;border-left:4px solid var(--accent);background:var(--muted);border-radius:0 8px 8px 0;font-style:italic;font-size:.9rem}
    #answerKey{margin-top:24px}
    .dashboard-metrics{display:flex;justify-content:space-between;gap:16px;margin-bottom:16px}
    .metric-box{flex:1;padding:12px;background:var(--muted);border-radius:8px;text-align:center}
    .metric-value{font-size:2rem;font-weight:bold;color:var(--accent)}
    .metric-label{font-size:.8rem;color:var(--text);margin-top:4px}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>SWLE Exam Builder</h1>
    <div class="row">
      <div class="col">
        <div class="card">
          <h2>Exam Builder</h2>
          <p>Generate a custom practice exam from a subject bank. Questions are distributed based on PRC's Table of Specifications.</p>
          <label for="subjectSelect">Subject</label>
          <select id="subjectSelect">
            <option value="HBSE">HBSE</option>
            <option value="SWPPS">SWPPS</option>
            <option value="Practice I">Practice I</option>
            <option value="Practice II">Practice II</option>
            <option value="Practice III">Practice III</option>
          </select>
          <label for="targetCount">Number of Questions</label>
          <input type="number" id="targetCount" min="10" max="100" value="50" />
          <button id="btnBuild">Build Exam</button>
          <p id="buildMsg"></p>
        </div>
      </div>
      <div class="col">
        <div class="card">
          <h2>Dashboard</h2>
          <div class="dashboard-metrics">
            <div class="metric-box">
              <div class="metric-value" id="examCount">0</div>
              <div class="metric-label">Exams Taken</div>
            </div>
            <div class="metric-box">
              <div class="metric-value" id="avgScore">0%</div>
              <div class="metric-label">Average Score</div>
            </div>
          </div>
          <p>Review your last completed exam. Your score is automatically saved.</p>
          <button id="btnReviewLastExam">Review Last Exam</button>
        </div>
      </div>
    </div>
    
    <div id="examPanel" class="card hide">
      <div class="row">
        <div class="col">
          <h2>Current Exam</h2>
        </div>
        <div class="col metrics">
          <div class="progress-wrap">
            <div id="bar"></div>
          </div>
          <div id="metaCount"></div>
          <div id="metaScore"></div>
        </div>
      </div>

      <div id="examList"></div>

      <div class="row" style="justify-content: flex-end;">
        <div class="col" style="min-width: 200px;">
          <button id="btnFinishExam" class="hide">Finish Exam</button>
          <button id="btnResetExam">Reset Exam</button>
        </div>
      </div>
    </div>
  </div>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        /***** STATE AND DOM ELEMENTS *****/
        let questions = []; 
        let currentExamQuestions = [];
        let userAnswers = {}; 

        const subjectSelect = document.getElementById('subjectSelect');
        const targetCount = document.getElementById('targetCount');
        const btnBuild = document.getElementById('btnBuild');
        const buildMsg = document.getElementById('buildMsg');
        const examPanel = document.getElementById('examPanel');
        const examList = document.getElementById('examList');
        const metaCount = document.getElementById('metaCount');
        const metaScore = document.getElementById('metaScore');
        const bar = document.getElementById('bar');
        const btnFinishExam = document.getElementById('btnFinishExam');
        const btnResetExam = document.getElementById('btnResetExam');
        const btnReviewLastExam = document.getElementById('btnReviewLastExam');
        const examCountEl = document.getElementById('examCount');
        const avgScoreEl = document.getElementById('avgScore');

        /***** SUBJECT ALLOCATION MATRICES (PRC TOS) *****/
        const ALLOCATIONS = {
            HBSE: { difficultySplit:{Easy:0.30, Moderate:0.40, Difficult:0.30}, topics:[ { key:"A1", topic:"Philippine Social Realities & Social Work Concepts/Tools", count:17 }, { key:"A2", topic:"Anatomy of Social Problems & Theories", count:3 }, { key:"B", topic:"Filipino Personality & Social Work", count:20 }, { key:"C", topic:"Social Work & Social Deviation", count:20 }, { key:"D", topic:"Social Environment: Family/Group/Community/Org", count:20 }, { key:"E", topic:"Social Change & Development Perspectives", count:20 }, ] },
            SWPPS: { difficultySplit:{Easy:0.30, Moderate:0.40, Difficult:0.30}, topics:[ { key:"A", topic:"Philippine Social Welfare & Development: History, Philosophy, Values", count:20 }, { key:"B", topic:"Social Welfare Policies, Laws, and Programs", count:30 }, { key:"C", topic:"Fields of Social Work & Delivery Systems", count:30 }, { key:"D", topic:"International and Regional Developments", count:20 } ] },
            "Practice I": { difficultySplit:{Easy:0.30, Moderate:0.40, Difficult:0.30}, topics:[ { key:"A", topic:"Social Work Practice with Individuals (Casework)", count:40 }, { key:"B", topic:"Theories, Methods, and Approaches in Casework", count:30 }, { key:"C", topic:"Practice Skills and Techniques", count:30 } ] },
            "Practice II": { difficultySplit:{Easy:0.30, Moderate:0.40, Difficult:0.30}, topics:[ { key:"A", topic:"Social Work Practice with Groups", count:40 }, { key:"B", topic:"Theories, Methods, and Approaches in Group Work", count:30 }, { key:"C", topic:"Practice Skills and Techniques in Group Work", count:30 } ] },
            "Practice III": { difficultySplit:{Easy:0.30, Moderate:0.40, Difficult:0.30}, topics:[ { key:"A", topic:"Social Work Practice with Communities & Organizations", count:40 }, { key:"B", topic:"Theories, Methods, and Approaches in Community/Org Practice", count:30 }, { key:"C", topic:"Practice Skills and Techniques in Community/Org Practice", count:30 } ] }
        };

        /***** UTILITY FUNCTIONS *****/
        const shuffle = (array) => {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        };
        const updateDashboard = () => {
            const scores = JSON.parse(localStorage.getItem('examScores') || '[]');
            examCountEl.textContent = scores.length;
            if (scores.length > 0) {
                const totalScore = scores.reduce((sum, score) => sum + score, 0);
                const average = Math.round(totalScore / scores.length);
                avgScoreEl.textContent = `${average}%`;
            } else {
                avgScoreEl.textContent = '0%';
            }
            btnReviewLastExam.disabled = !localStorage.getItem('lastExamQuestions');
        };

        /***** DATA LOADING LOGIC *****/
        const loadCombinedData = async () => {
            try {
                const response = await fetch('combined_data.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                questions = await response.json();
                buildMsg.textContent = `Successfully loaded ${questions.length} items.`;
                buildMsg.style.color = 'var(--good)';
                console.log(`Loaded ${questions.length} questions from combined_data.json`);
            } catch (error) {
                console.error("Could not load the combined data:", error);
                buildMsg.textContent = `Error loading data: ${error.message}`;
                buildMsg.style.color = 'var(--bad)';
            }
        };

        /***** EXAM BUILDING LOGIC *****/
        btnBuild.addEventListener('click', () => {
            const subject = subjectSelect.value;
            const totalItems = parseInt(targetCount.value);
            const bank = questions.filter(q => q.subject === subject);

            if (bank.length === 0) {
                buildMsg.textContent = `Question bank for ${subject} is empty.`;
                buildMsg.style.color = 'var(--warn)';
                return;
            }

            const allocation = ALLOCATIONS[subject];
            let selectedQuestions = [];
            let tempBank = shuffle([...bank]);

            const requiredEasy = Math.round(totalItems * allocation.difficultySplit.Easy);
            const requiredMod = Math.round(totalItems * allocation.difficultySplit.Moderate);
            const requiredDiff = totalItems - requiredEasy - requiredMod;

            const easyQs = tempBank.filter(q => q.difficulty === 'Easy');
            const modQs = tempBank.filter(q => q.difficulty === 'Moderate');
            const diffQs = tempBank.filter(q => q.difficulty === 'Difficult');

            selectedQuestions.push(...easyQs.slice(0, requiredEasy));
            selectedQuestions.push(...modQs.slice(0, requiredMod));
            selectedQuestions.push(...diffQs.slice(0, requiredDiff));
            
            let remaining = totalItems - selectedQuestions.length;
            if(remaining > 0){
              const remainingQs = tempBank.filter(q => !selectedQuestions.includes(q));
              selectedQuestions.push(...remainingQs.slice(0, remaining));
            }

            if (selectedQuestions.length < totalItems) {
                buildMsg.textContent = `Warning: Not enough questions in the bank to meet the ${totalItems} target. Built with ${selectedQuestions.length}.`;
                buildMsg.style.color = 'var(--warn)';
            } else {
                buildMsg.textContent = `Successfully built exam with ${selectedQuestions.length} items.`;
                buildMsg.style.color = 'var(--good)';
            }

            currentExamQuestions = shuffle(selectedQuestions);
            userAnswers = {};
            renderExam();
        });

        /***** EXAM RENDERING AND INTERACTION *****/
        const renderExam = (examToRender = currentExamQuestions, answersToRender = userAnswers) => {
            examPanel.hidden = false;
            btnFinishExam.classList.add('hide');
            examList.innerHTML = '';
            
            examToRender.forEach((q, index) => {
                const questionEl = document.createElement('div');
                questionEl.className = 'q';
                questionEl.dataset.id = q.id;

                const shuffledChoices = shuffle([...q.choices]);
                const choicesHTML = shuffledChoices.map((choice, choiceIndex) => `
                    <div class="choice" data-original-index="${q.choices.indexOf(choice)}">
                        ${choice}
                    </div>
                `).join('');

                questionEl.innerHTML = `
                    <div><b>${index + 1}.</b> ${q.stem}</div>
                    <div class="choices">${choicesHTML}</div>
                    <div class="rationale hide">${q.rationale}</div>
                `;
                examList.appendChild(questionEl);
            });
            updateStats(examToRender, answersToRender);
        };

        examList.addEventListener('click', (e) => {
            if (e.target.classList.contains('choice')) {
                const questionEl = e.target.closest('.q');
                const questionId = questionEl.dataset.id;
                const selectedOriginalIndex = parseInt(e.target.dataset.originalIndex);
                
                if (userAnswers[questionId] !== undefined) return; // Prevents re-selection

                userAnswers[questionId] = selectedOriginalIndex;
                
                // Highlight choice immediately but do not show correct answer
                questionEl.querySelectorAll('.choice').forEach(choice => choice.classList.remove('selected'));
                e.target.classList.add('selected');
                
                updateStats();
            }
        });

        const updateStats = (exam = currentExamQuestions, answers = userAnswers) => {
            const answeredCount = Object.keys(answers).length;
            const totalCount = exam.length;
            
            metaCount.textContent = `Answered: ${answeredCount}/${totalCount}`;
            bar.style.width = `${(answeredCount / totalCount) * 100}%`;
            
            if (answeredCount === totalCount && totalCount > 0) {
                btnFinishExam.classList.remove('hide');
                metaScore.textContent = 'Ready to Finish!';
            } else {
                btnFinishExam.classList.add('hide');
                metaScore.textContent = '...';
            }
        };
        
        const showResults = () => {
            let correctCount = 0;
            const totalCount = currentExamQuestions.length;
            
            currentExamQuestions.forEach(q => {
                const questionEl = document.querySelector(`[data-id="${q.id}"]`);
                const userChoiceEl = questionEl.querySelector(`[data-original-index="${userAnswers[q.id]}"]`);
                const correctChoiceEl = questionEl.querySelector(`[data-original-index="${q.answerIndex}"]`);
                const rationaleEl = questionEl.querySelector('.rationale');

                const isCorrect = userAnswers[q.id] === q.answerIndex;
                if (isCorrect) {
                    correctCount++;
                }

                if (userChoiceEl) {
                    userChoiceEl.classList.remove('selected');
                    userChoiceEl.classList.add(isCorrect ? 'correct' : 'wrong');
                }
                correctChoiceEl.classList.add('correct');
                rationaleEl.classList.remove('hide');
            });

            const score = totalCount > 0 ? Math.round((correctCount / totalCount) * 100) : 0;
            metaScore.textContent = `Final Score: ${score}%`;
            
            // Save score to dashboard
            const scores = JSON.parse(localStorage.getItem('examScores') || '[]');
            scores.push(score);
            localStorage.setItem('examScores', JSON.stringify(scores));
            updateDashboard();

            // Save this exam for review
            localStorage.setItem('lastExamQuestions', JSON.stringify(currentExamQuestions));
            localStorage.setItem('lastUserAnswers', JSON.stringify(userAnswers));

            btnFinishExam.classList.add('hide');
        };

        /***** EXAM CONTROLS *****/
        btnResetExam.addEventListener('click', () => {
            userAnswers = {};
            renderExam();
        });

        btnFinishExam.addEventListener('click', () => {
            showResults();
        });

        btnReviewLastExam.addEventListener('click', () => {
            const lastQs = JSON.parse(localStorage.getItem('lastExamQuestions'));
            const lastAnswers = JSON.parse(localStorage.getItem('lastUserAnswers'));
            if (lastQs && lastAnswers) {
                renderReview(lastQs, lastAnswers);
            } else {
                alert('No previous exam found to review.');
            }
        });

        const renderReview = (examToRender, answersToRender) => {
            examPanel.hidden = false;
            examList.innerHTML = '';
            btnFinishExam.classList.add('hide');
            
            examToRender.forEach((q, index) => {
                const questionEl = document.createElement('div');
                questionEl.className = 'q';
                questionEl.dataset.id = q.id;

                const choicesHTML = q.choices.map((choice, choiceIndex) => `
                    <div class="choice" data-original-index="${choiceIndex}">
                        ${choice}
                    </div>
                `).join('');

                questionEl.innerHTML = `
                    <div><b>${index + 1}.</b> ${q.stem}</div>
                    <div class="choices">${choicesHTML}</div>
                    <div class="rationale">${q.rationale}</div>
                `;
                examList.appendChild(questionEl);
            });

            // Apply coloring based on answers
            examToRender.forEach(q => {
                const questionEl = document.querySelector(`[data-id="${q.id}"]`);
                const userAnswer = answersToRender[q.id];

                if (userAnswer !== undefined) {
                    const userChoiceEl = questionEl.querySelector(`[data-original-index="${userAnswer}"]`);
                    const isCorrect = userAnswer === q.answerIndex;
                    if(userChoiceEl) {
                        userChoiceEl.classList.add(isCorrect ? 'correct' : 'wrong');
                    }
                }
                
                const correctChoiceEl = questionEl.querySelector(`[data-original-index="${q.answerIndex}"]`);
                correctChoiceEl.classList.add('correct');
            });
            
            const answeredCount = Object.keys(answersToRender).length;
            const totalCount = examToRender.length;
            let correctCount = 0;
            for(const qId in answersToRender) {
                const q = examToRender.find(item => item.id === qId);
                if(q && answersToRender[qId] === q.answerIndex) {
                    correctCount++;
                }
            }
            const score = totalCount > 0 ? Math.round((correctCount / totalCount) * 100) : 0;

            metaCount.textContent = `Answered: ${answeredCount}/${totalCount}`;
            metaScore.textContent = `Score: ${score}% (Review Mode)`;
            bar.style.width = `${(answeredCount / totalCount) * 100}%`;
        };

        /***** INITIALIZATION *****/
        loadCombinedData();
        updateDashboard();
    });
</script>
</body>
</html>
